<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Hologram</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; }
        #noise {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.05'/%3E%3C/svg%3E");
            pointer-events: none; z-index: 10;
        }
        #ui {
            position: absolute; bottom: 20px; left: 20px; color: #00ffff;
            font-family: 'Courier New', monospace; font-size: 12px; z-index: 20;
            pointer-events: none; opacity: 0.7;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="noise"></div>
    <div id="ui">YOU CAN SCROLL!<br>RENDER: POST-PROCESSING ENABLED<br>PARTICLES: A LOT</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 1. БАЗА, ФУНДАМЕНТ, ОСНОВА ТАК СКАЗАТЬ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- 2. POST-PROCESSING (BLOOM) ---
        const renderScene = new RenderPass(scene, camera);
        
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = 2.0;
        bloomPass.radius = 0.5;
        bloomPass.threshold = 0;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 3. Objects ---

        // Core
        const coreGeo = new THREE.IcosahedronGeometry(3, 1);
        const coreMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            wireframe: true,
            transparent: true,
            opacity: 0.3
        });
        const core = new THREE.Mesh(coreGeo, coreMat);
        scene.add(core);

        // Meshes (InstancedMesh)
        const particlesCount = 3000;
        const dummy = new THREE.Object3D();

        const pGeo = new THREE.BoxGeometry(0.05, 0.05, 0.05);
        const pMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const instancedParticles = new THREE.InstancedMesh(pGeo, pMat, particlesCount);
        
        for (let i = 0; i < particlesCount; i++) {
            const r = 4 + Math.random() * 2;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            dummy.position.set(x, y, z);
            dummy.lookAt(0, 0, 0);
            dummy.updateMatrix();
            instancedParticles.setMatrixAt(i, dummy.matrix);
        }
        scene.add(instancedParticles);

        // КОЛЬЦА
        const rings = [];
        const createRing = (radius, speedX, speedY) => {
            const geo = new THREE.TorusGeometry(radius, 0.02, 16, 100);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff00aa, transparent: true, opacity: 0.5 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.userData = { speedX, speedY };
            scene.add(mesh);
            rings.push(mesh);
        };

        createRing(3.5, 0.01, 0.005);
        createRing(4.0, -0.01, 0.01);
        createRing(4.5, 0.02, 0);

        // --- 4. ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();

            const scale = 1 + Math.sin(time * 2) * 0.05;
            core.scale.set(scale, scale, scale);
            core.rotation.y += 0.005;

            rings.forEach(ring => {
                ring.rotation.x += ring.userData.speedX;
                ring.rotation.y += ring.userData.speedY;
            });

            instancedParticles.rotation.y = time * 0.1;
            instancedParticles.rotation.z = time * 0.05;

            controls.update();
            composer.render();
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
